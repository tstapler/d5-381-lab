DEPTH=1024; 	% Memory depth and width are required 
		% DEPTH is the number of addresses 
WIDTH = 32; 	% WIDTH is the number of bits of data per word
		% DEPTH and WIDTH should be entered as decimal numbers

ADDRESS_RADIX = DEC; 	% Address and value radixes are required
DATA_RADIX = BIN; 	% Enter BIN, DEC, HEX, OCT, or UNS; unless
			% otherwise specified, radixes = HEX

-- Specify values for addresses, which can be single address or range
-- SOME THINGS TO CONSIDER
-- 1) This memory is word-addressable, versus the MIPS conceptual byte-addressable memory.
--    This means that address 1 corresponds to word 1, address 2 corresponds to word 2, etc.
--    Since MIPS will be generating byte addresses, you will have to create some (very simple)
--    logic in your VHDL wrapper to deal with byte/word offsets. 
-- 2) The "single address" notation seems to be least likely to cause confusion so that is what
--    I recommend. 
-- 3) The values need to be in 32-bit hex form (i.e. don't use F when you really mean 0000000F).

-- Sample C code:
--   if (a != b) c = a + b;
-- Assume a @ 0x0000($zero), b @ 0x0004($zero), c @ 0x0008($zero0
-- Assembly code:
--      lw   $t0, 0($zero)
--      lw   $t1, 4($zero)
--      beq  $t0, $t1, +2
--      add  $t0, $t0, $t1
--      sw   $t0, 8($zero)
--      noop
--      beq  $zero, $zero, -1    # idle loop
CONTENT
BEGIN
-- Instruction formats
--R ======-----=====-----=====------
--I ======-----=====----------------
--J ======--------------------------
0 : 
00111100000001000001000000000001
00110100100001000000000000000000
00111100000001010000000000000000
00110100101001010000000000001010
00001100000100000000000000001000
00001000000100000000000000000101
00000000000000000000000000000000
00000000000000000000000000000000
00100011101111011111111111101100
10101111101111110000000000010000
10101111101100110000000000001100
10101111101100100000000000001000
10101111101100010000000000000100
10101111101100000000000000000000
00000000000001001001000000100001
00000000000001011001100000100001
00000000000000001000000000100001
00000010000100110100000000101010
00010001000000000000000000010000
00100010000100011111111111111111
00101010001010000000000000000000
00010101000000000000000000001011
00000000000100010100100010000000
00000010010010010101000000100000
10001101010010110000000000000000
10001101010011000000000000000100
00000001100010110100000000101010
00010001000000000000000000000101
00000000000100100010000000100001
00000000000100010010100000100001
00001100000100000000000000101010
00100010001100011111111111111111
00001000000100000000000000010100
00100010000100000000000000000001
00001000000100000000000000010001
10001111101100000000000000000000
10001111101100010000000000000100
10001111101100100000000000001000
10001111101100110000000000001100
10001111101111110000000000010000
00100011101111010000000000010100
00000011111000000000000000001000
00000000000001010100100010000000
00000000100010010100100000100000
10001101001010000000000000000000
10001101001010100000000000000100
10101101001010100000000000000000
10101101001010000000000000000100
00000011111000000000000000001000;
 			
END;
